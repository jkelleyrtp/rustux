/// A communication element shared by multiple Yew elements is simply a struct decorated with the 
/// 

/// #[Rustux(state=RustuxStore)]
/// pub struct title_struct {
///     enum Color ( Blue,  Yellow )
/// }
/// 
/// impl title_struct{
/// 
/// }
/// 
/// 
/// 
/// RS::title_stsruct.subscribe( title_struct::Color,  { Self::DoSomething })
/// 
/// RS is the container struct generated by Rustux to manage golbal and page specific state. 
/// Because RS is autogenerated from the various states defined in the user's code,
/// it is dynamically serializable.
/// 
/// Is there any reason for one page to talk to another page without existing in the global state? No,
/// this can be achieved by pushing a global state and having two agents subscribe
/// 
/// RS::Global
/// 
/// RS::ThisPage
/// 
/// RS::Global::Shared
/// 
/// Things like:
///     Who/how many subscribed?
///     Trigger on subscriber left chanel ( pass subscriber )
///     Trigger on subscriber joined channel ( pass subscriber )
///     Trigger on specific user chatted on channel ( message )
///     Subscriptions - Act on incoming messages
///     Pubscriptions - Send messages on internal actions
/// 
/// 
/// 
/// 


use yew::worker::*;

struct Worker {
    link: AgentLink<Worker>,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum Request {
    Question(String),
}

#[derive(Serialize, Deserialize, Debug)]
pub enum Response {
    Answer(String),
}

impl Agent for Worker {
    // Available:
    // - `Job` (one per bridge)
    // - `Context` (shared in the same thread)
    // - `Public` (separate thread).
    type Reach = Context; // Spawn only one instance per thread (all components could reach this)
    type Message = Msg;
    type Input = Request;
    type Output = Response;

    // Create an instance with a link to agent's environment.
    fn create(link: AgentLink<Self>) -> Self {
        Worker { link }
    }

    // Handle inner messages (of services of `send_back` callbacks)
    fn update(&mut self, msg: Self::Message) { /* ... */ }

    // Handle incoming messages from components of other agents.
    fn handle(&mut self, msg: Self::Input, who: HandlerId) {
        match msg {
            Request::Question(_) => {
                self.link.response(who, Response::Answer("That's cool!".into()));
            },
        }
    }
}





